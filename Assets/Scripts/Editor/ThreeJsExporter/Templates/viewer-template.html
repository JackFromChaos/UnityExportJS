<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity Scene Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Инициализация сцены и рендерера
        const scene = new THREE.Scene();
        let camera;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x222222);
        document.body.appendChild(renderer.domElement);

        // Встроенные JSON-данные сцены
        const sceneData = {{SCENE_DATA}};

        // Создаем загрузчик THREE.ObjectLoader
        const loader = new THREE.ObjectLoader();
        
        // Загружаем сцену
        let loadedScene;
        try {
            // Загружаем объекты из JSON
            loadedScene = loader.parse(sceneData.scene);
            console.log('Scene loaded successfully:', loadedScene);
        } catch (error) {
            console.error("Error loading scene:", error);
            loadedScene = new THREE.Scene(); // Создаем пустую сцену в случае ошибки
        }
        
        // Создаем и добавляем камеру
        if (sceneData.camera && sceneData.camera.object) {
            const cameraData = sceneData.camera.object;
            camera = new THREE.PerspectiveCamera(
                cameraData.fov, 
                window.innerWidth / window.innerHeight,
                cameraData.near, 
                cameraData.far
            );
            
            // Устанавливаем позицию и ориентацию камеры
            camera.position.set(
                cameraData.position[0],
                cameraData.position[1],
                cameraData.position[2]
            );
            
            camera.rotation.set(
                cameraData.rotation[0],
                cameraData.rotation[1],
                cameraData.rotation[2]
            );
        } else {
            // Если камера не найдена в JSON, создаем стандартную
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
        }
        
        // Добавляем элементы из загруженной сцены в нашу сцену
        if (loadedScene && loadedScene.children) {
            loadedScene.children.forEach(child => {
                // Добавляем только меши и группы, исключая камеры
                if (child.type === 'Mesh' || child.type === 'Group') {
                    scene.add(child.clone());
                }
            });
        }
        
        // Создаем геометрию куба, если она определена в JSON
        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        
        // Добавляем кубы, определенные в JSON
        sceneData.scene.object.children.forEach(child => {
            if (child.geometry === 'cube-geometry') {
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                
                // Устанавливаем позицию, поворот и масштаб куба
                if (child.position) {
                    cube.position.set(child.position[0], child.position[1], child.position[2]);
                }
                
                if (child.rotation) {
                    cube.rotation.set(child.rotation[0], child.rotation[1], child.rotation[2]);
                }
                
                if (child.scale) {
                    cube.scale.set(child.scale[0], child.scale[1], child.scale[2]);
                }
                
                scene.add(cube);
            }
            
            // Рекурсивно обрабатываем дочерние объекты
            if (child.children && child.children.length > 0) {
                processChildren(child.children, scene, cubeGeometry, cubeMaterial, child.position || [0, 0, 0], child.rotation || [0, 0, 0], child.scale || [1, 1, 1]);
            }
        });
        
        // Функция для рекурсивной обработки дочерних объектов
        function processChildren(children, parentObject, geometry, material, parentPosition, parentRotation, parentScale) {
            children.forEach(child => {
                if (child.geometry === 'cube-geometry') {
                    const cube = new THREE.Mesh(geometry, material);
                    
                    // Устанавливаем позицию, поворот и масштаб куба с учетом родительских трансформаций
                    if (child.position) {
                        cube.position.set(
                            parentPosition[0] + child.position[0], 
                            parentPosition[1] + child.position[1], 
                            parentPosition[2] + child.position[2]
                        );
                    }
                    
                    if (child.rotation) {
                        cube.rotation.set(
                            parentRotation[0] + child.rotation[0],
                            parentRotation[1] + child.rotation[1],
                            parentRotation[2] + child.rotation[2]
                        );
                    }
                    
                    if (child.scale) {
                        cube.scale.set(
                            parentScale[0] * child.scale[0],
                            parentScale[1] * child.scale[1],
                            parentScale[2] * child.scale[2]
                        );
                    }
                    
                    parentObject.add(cube);
                } else if (child.type === 'Group') {
                    const group = new THREE.Group();
                    group.name = child.name;
                    
                    // Устанавливаем позицию, поворот и масштаб группы
                    if (child.position) {
                        group.position.set(child.position[0], child.position[1], child.position[2]);
                    }
                    
                    if (child.rotation) {
                        group.rotation.set(child.rotation[0], child.rotation[1], child.rotation[2]);
                    }
                    
                    if (child.scale) {
                        group.scale.set(child.scale[0], child.scale[1], child.scale[2]);
                    }
                    
                    parentObject.add(group);
                    
                    // Обрабатываем дочерние объекты группы
                    if (child.children && child.children.length > 0) {
                        processChildren(child.children, group, geometry, material, child.position || [0, 0, 0], child.rotation || [0, 0, 0], child.scale || [1, 1, 1]);
                    }
                }
            });
        }
        
        // Добавление орбитальных контролов для управления камерой
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Добавление освещения
        const ambientLight = new THREE.AmbientLight(0x404040); // мягкий белый свет
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Обработка изменения размера окна
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Анимационный цикл
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Запуск анимационного цикла
        animate();
    </script>
</body>
</html>